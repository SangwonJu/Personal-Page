---
title: "EDA Assignment 3: Chapter 5"
author: "Sangwon Ju, Yonsei Public Administration"
date: 'apr/07/2021'
page-layout: full
format: 
    html
categories: 
    "Exploratory Data Analysis (2021 Spring) [in Korean]"
image: "image.png"
---

5장. 자료의 재표현

# 1번

적당한 범위에서 x의 1/2승, 1/3승, 1/4승, log 함수 그래프를 그려 함수의 기울어진 형태가 log 함수 쪽으로 변하는 것을 보여라. 반대로 x의 -1/2, -1/3, -1/4, log 함수 그래프를 그려 함수의 기울어진 정도가 log 함수로 수렴하는 것을 보여라.

```{r}
library(ggplot2)
library(reshape)


#적당한 범위에서 x의 1/2승, 1/3승, 1/4승, log 함수 그래프를 그려 함수의 기울어진 형태가 log 함수 쪽으로 변하는 것을 보여라.

x=seq(0,10000,1)
y=seq(0,10000,1)


ggplot()+
  geom_point(aes(x,y))+
  labs(title = "y=x Graph", x = "X", y = "Y",fill="count") +
  theme(axis.title.x = element_text(face="bold", size=19, colour="black")) +
  theme(axis.title.y = element_text(face="bold", size=19, colour="black"))

ggplot()+
  geom_point(aes(x,y^2))+
  labs(title = "y=x^2 Graph", x = "X", y = "Y",fill="count") +
  theme(axis.title.x = element_text(face="bold", size=19, colour="black")) +
  theme(axis.title.y = element_text(face="bold", size=19, colour="black"))

comparison=data.frame(x,y^(1/2),y^(1/3),y^(1/4),log(y+1e-05))
names(comparison)=c("x","y의 1/2승","y의 1/3승","y의 1/4승","logarithm")

compare2=melt(comparison,id="x")

# 기본
ggplot()+
  geom_line(aes(x,y))+
  labs(title = "y=x", x = "X", y = "Y",fill="count") +
  theme(axis.title.x = element_text(face="bold", size=19, colour="black")) +
  theme(axis.title.y = element_text(face="bold", size=19, colour="black"))

# 1/2 승
ggplot()+
  geom_line(aes(x,y^(1/2)))+
  labs(title = "y=x^2 Graph", x = "X", y = "Y",fill="count") +
  theme(axis.title.x = element_text(face="bold", size=19, colour="black")) +
  theme(axis.title.y = element_text(face="bold", size=19, colour="black"))

# 1/3 승
ggplot()+
  geom_line(aes(x,y^(1/3)))+
  labs(title = "y=x^3 Graph", x = "X", y = "Y",fill="count") +
  theme(axis.title.x = element_text(face="bold", size=19, colour="black")) +
  theme(axis.title.y = element_text(face="bold", size=19, colour="black"))

# 1/4 승
ggplot()+
  geom_line(aes(x,y^(1/4)))+
  labs(title = "y=x^4 Graph", x = "X", y = "Y",fill="count") +
  theme(axis.title.x = element_text(face="bold", size=19, colour="black")) +
  theme(axis.title.y = element_text(face="bold", size=19, colour="black"))

# 로그함수일때
ggplot()+
  geom_line(aes(x,log(y+1e-03)))+
  labs(title = "y=x^2 Graph", x = "X", y = "Y",fill="count") +
  theme(axis.title.x = element_text(face="bold", size=19, colour="black")) +
  theme(axis.title.y = element_text(face="bold", size=19, colour="black"))

# 함수 여러개 비교
ggplot(compare2,aes(x=x,y=value))+
  theme_bw()+
  geom_line(aes(y=value,color=variable),size=2)+
  theme(axis.title.x = element_text(face="bold", size=19, colour="black")) +
  theme(axis.title.y = element_text(face="bold", size=19, colour="black"))
```

Power의 값이 x의 1/2승, 1/3승, 1/4승으로 작아질 수록 log함수로 수렴하고 있음을 확인할 수 있다.

```{r}
# 반대로 x의 -1/2, -1/3, -1/4, log 함수 그래프를 그려 함수의 기울어진 정도가 log 함수로 수렴하는 것을 보여라.
x1=seq(1,100,1)
y1=seq(1,100,1)


comparison3=data.frame(x1,y1^(-1/4),y1^(-1/3),y1^(-1/2),log(y1+1e-05))
names(comparison3)=c("x","y의 -1/4승","y의 -1/3승","y의 -1/2승","logarithm")

compare3=melt(comparison3,id="x")
# 함수 여러개 비교
ggplot(compare3,aes(x=x,y=value))+
  theme_bw()+
  geom_line(aes(y=value,color=variable),size=2)+
  theme(axis.title.x = element_text(face="bold", size=19, colour="black")) +
  theme(axis.title.y = element_text(face="bold", size=19, colour="black"))
```

Power의 값이 x의 -1/2승, -1/3승, -1/4승으로 증가할수록 log함수로 수렴하고 있음을 확인할 수 있다.

# 2번

2020년 1월 1일부터 2021년 4월 6일까지의 삼성전자 주식 가격을 인터넷에서 찾아 줄기잎 전시와 상자그림을 그려 대칭성을 점검하고 필요하다면 대칭화하는 변환을 시행착오 방법으로 찾아라. 어떤 시행착오로 찾아갔는지 중간 과정을 전부 보여라. 변환 후의 줄기잎 전시와 상자그림을 그려 전, 후를 비교하여라. 변환 전, 후의 skewness 값을 비교하여라.

## 크롤링을 통해 삼성전자 주식가격 데이터 확인

```{r}
pacman::p_load("rvest","httr","lubridate","R6","tidyverse",
               "xml2","stringr","readr","tqk","XML")
remotes::install_github("mrchypark/tqk")
```

```{r}
code_samsung=function () 
{    . <- MKT_TP_NM <- ISU_ABBRV <- ISU_SRT_CD <- ISU_NM <- ISU_ENG_NM <- ISU_CD <- NULL
    "http://data.krx.co.kr/comm/bldAttendant/getJsonData.cmd" %>% 
        httr::POST(body = list(bld = "dbms/MDC/STAT/standard/MDCSTAT01901", 
            locale = "ko_KR", mktId = "ALL", share = 1, csvxls_isNo = "false"), 
            encode = "form") %>% 
        httr::content("text") %>% 
        jsonlite::fromJSON() %>% 
        .$OutBlock_1 %>% 
        tibble() %>% 
        dplyr::transmute(
            market = MKT_TP_NM, 
            name = ISU_ABBRV, 
            code = ISU_SRT_CD, 
            name_full = ISU_NM,
            name_eng = ISU_ENG_NM, 
            code_full = ISU_CD) %>%
    
        dplyr::filter(stringr::str_detect(name,pattern="삼성+")) %>% 
        return() 
}
```

```{r}
# 삼성전자 코드
code_samsung()
samsung <- code_samsung() %>% 
    select(name,code) %>% 
    filter(name=="삼성전자")
```

삼성전자 코드는 005930

```{r}
samsung$code
url="https://fchart.stock.naver.com/sise.nhn?timeframe=day&count=6000&requestType=0&symbol="
samsung_data=read_xml(glue::glue({url},samsung$code))

splitting=function(a){
    result=str_split(a,pattern="\\|",simplify=T)
    result=data.frame(result)
    names(result)=c('date','시가','고가','저가','종가',"거래량")
    return(result)}

samsung <- samsung_data %>%
    xmlParse(useInternalNodes = TRUE) %>% 
    xmlToList() %>% 
    plyr::ldply(tibble) %>%
    select(data1="<named list>") %>% 
    unlist() %>% 
    tibble(data1=as.character(.)) %>% 
    select(data1) %>% 
    do(head(., nrow(.)-6)) %>% 
    transmute(data2=map(data1,splitting)) %>% 
    unnest(data2) %>% 
    mutate_all(.funs=as.numeric) %>% 
    mutate(date=ymd(date)) %>% 
    filter(date>=ymd(20200101) & date<=ymd(20210406))

library(ggplot2)
ggplot(samsung, aes(x = date, y = 시가)) +
    theme_bw()+
    geom_line(size=1, color = "blue") + 
    ggtitle("삼성전자 시가 변화 추이") +
    ggeasy::easy_center_title()
  
# install.packages("reshape")
library(reshape)
samsung1=samsung %>% 
    select(-거래량) %>% 
    pivot_longer(!date,names_to="variable",values_to="value")

# 주가 추이 시각화
ggplot(samsung1, aes(x = date, y = value)) +
    theme_minimal()+
    geom_line(size=1, aes(colour=variable)) + 
    ggtitle("삼성전자 주가 변화 추이")+
    scale_color_discrete(name="주가 유형")+
    labs(y="주가",x="거래일")+
    scale_x_date(date_breaks = "months" , date_labels = "%b/%y")+
    scale_y_continuous(limits = c(40000,96000), breaks=seq(40000,96000,5000))+
    ggeasy::easy_center_title()+
    ggeasy::easy_rotate_x_labels()

max(samsung$고가)-min(samsung$저가)

fivenum(samsung$시가)[4]-fivenum(samsung$시가)[2]
18450/1.35
```

고점과 저점 비교시 54500 정도의 변동성 존재

hspread: 18450정도이고 pseudo-sigma 13666.67 정도. 한국 코스피 변동성을 계산하여 표준편차를 확인하고 이를 계산된 변동성과 비교한다면 삼성전자 주식의 안정성에 대해서 예측해볼 수 있다. (단순히 상승했다, 상승하지 않았다 정도의 지식에 더해 주식의 변동성을 이해한다면 안정적인 주식인지 안정적이지 않은 주식인지 확인할 수 있다.)

이후 시계열 분석을 활용해 추가적인 분석이 요구됨

주식 가격을 인터넷에서 찾아 줄기잎 전시와 상자그림을 그려 대칭성을 점검 - 주식 가격은 시가를 기준으로 파악한다.

```{r}
#Stem and Leaf
stem(samsung$시가)
#Boxplot
ggplot(samsung1, aes(x = variable, y = value))+
    ggtitle("삼성전자 주가 변화 추이")+
    geom_boxplot(aes(fill=variable))+
    labs(y="주가",x='주가 유형')+
    theme_minimal()+
    ggeasy::easy_center_title()
```

박스플롯 상으로는 자료들의 대칭성을 어느정도 확인할 수 있다. 특이값이 없는 대신 큰쪽의 Whisker의 길이가 작은쪽의 Whisker의 길이에 비해서 긴 것으로 확인된다. 또한 Median의 값이 Lower-hinge 쪽에 더 가까운 것 이 확인되기 때문에 Skewed to the right에 해당하는 분포로 보인다. Stem-leaf Display에서는 두개의 cluster를 확인할 수 있는데, stem 58을 기준으로한 하나의 cluster와 stem 82를 기준으로 한 또 하나의 cluster가 있다. 작은 쪽의 cluster가 더 큰쪽의 cluster에 비해서 더 많은 숫자들을 가지고 있는 것을 확인할 수 있다.

```{r}
skewness = function(x) {
  hl=fivenum(x)[2]
  median=fivenum(x)[3]
  hu=fivenum(x)[4]
  skew=((hu-median)-(median-hl))/((hu-median)+(median-hl))
  return(skew)
}
skewness(samsung$시가)
```

A measure of symmetry로 skewness 값을 계산할 경우 0.46정도로 skewed to the right 되어 있음을 확인할 수 있다.

Skewness를 조절하기 위해서 수업시간에 제시한 4가지 방법들을 적용해보고자 한다.

```{r}
# Log
stem(log(samsung$시가))
boxplot(log(samsung$시가))

# sqrt
stem(sqrt(samsung$시가))
boxplot(sqrt(samsung$시가))

# minus inverse
stem(-1/(samsung$시가))
boxplot(-1/(samsung$시가))

# minus inverse of sqrt
stem(-1/sqrt((samsung$시가)))
boxplot(-1/sqrt((samsung$시가)))

```

Skewness 값을 변환전후로 비교

```{r}
skewness(samsung$시가)
skewness(log(samsung$시가))
skewness(sqrt(samsung$시가))
skewness(-1/(samsung$시가)) # 가장 낮은 수준의 Skewness를 보여줌
skewness(-1/sqrt(samsung$시가))

```

일반적으로 사용하는 변환으로는 만족스러운 수준으로 skewness 값이 감소되었는지 알수가 없었다. 따라서 skewness 값을 감소시키기 위해 함수를 활용하여 가능한 여러 경우의 값들을 비교해보고자 한다. (skewness값은 0일때 최소가 되고, 이때 자료가 대칭적이 되었다고 가정할 수 있다.)

```{r}
s=c()
start=samsung$시가
for (i in seq(-10,10,0.1)) {
  if(i>0){
    s = c(s,skewness(start^i))
  }
  
  else if(i==0){
    s = c(s,skewness(log(start)))
  }
  
  else{
    s = c(s,skewness(-(start^i)))
  }
}
y=cbind(seq(-10,10,0.1),s)
plot(y,xlab="Power Value",ylab="Skewness")
abline(h=0)
# -6정도일때 Skewness 자체는 최소가 된다. 
boxplot(-(start^-6))
```

skewness공식은 ((Hu-M)-(M-Hl))/((Hu-M)+(M-Hl))이다.

skewness의 공식이 H-Spread 범위의 Lower Hinge Upper Hinge 등에 의해서 만들어지기 때문에 i=-6을 활용할 경우 Spread 내부의 Symmery는 보정이 되었지만 Whisker의 길이가 오히려 길어졌다는 점에서 처음에 사용하였던 기존의 변환을 활용해보고자 한다.

```{r}
par(mfrow=c(2,3))
boxplot(log(samsung$시가))
boxplot(sqrt(samsung$시가))
boxplot(-1/sqrt((samsung$시가)))
boxplot(-1/(samsung$시가)) # 선택
boxplot(-1/(samsung$시가)^2)
boxplot(-1/(samsung$시가)^3)
```

다시한번 확인해보면, H-spread 내의 대칭성 정도 및 Whisker의 길이 까지 고려하여 가장 적절한 변환을 선택한다면 minus inverse 변환이나 minus sqrt inverse 변환 둘중에서 선택하면 된다고 본다. skewness가 더 0에 가까운 minus inverse 변환을 활용해서 데이터를 변환한다면 H-spread내 Hinge와 Median의 대칭성 그리고 whisker들의 대칭성 모두 다 확보할수 있다고 생각한다.

```{r}
decided=-1/(samsung$시가)
hist(decided,breaks=20) # 그럼에도 불구하고 stem and leaf display에서 확인하였던 오른쪽의 두번째 Cluster의 흔적은 사라지지 않고 남아 있다.
abline(v=median(decided),col="red")
```

# 3번

airquality 자료에서 Ozone 자료를 대칭화하기 위한 변환공식을 이용하여 변환 전과 변화 후를 비교하여라. 변환 후의 줄기잎 전시와 상자그림을 그려 전, 후를 비교하여라. 변환 전, 후의 skewness 값을 비교하여라.

```{r}
data(airquality)
attach(airquality)
str(Ozone)
summary(Ozone)

library(ggplot2)


sum(is.na(Ozone)) # 37개의 결측치


skewness = function(x) {
  hl=fivenum(x)[2]
  median=fivenum(x)[3]
  hu=fivenum(x)[4]
  skew=((hu-median)-(median-hl))/((hu-median)+(median-hl))
  return(skew)
}

# 변환전 
stem(Ozone)
ggplot()+
  theme_bw()+
  stat_boxplot(aes(Ozone),fill="pink")+
  labs(title="Ozone Boxplot before conversion")+
  coord_flip()

skewness(Ozone) 
```

```{r}

# Handout에 제시된 Conversion 공식을 활용했다.
conversion=function(x){
  m=fivenum(x)[3]
  hu=fivenum(x)[4]
  hl=fivenum(x)[2]
  k=1-(2*m*((hu-m)+(hl-m))/((hu-m)^2+(hl-m)^2))
  return(k)
}

conversion(airquality$Ozone)

# 0.3378238 정도로 0에 가까워 로그를 활용한 변환을 진행하고자 한다. 

#변환 후 (오존이 1인 데이터 로그 Transformation 오류 방지를 위해 매우 작은 숫자를 더해주자)
stem(log(Ozone+1e-04))
ggplot(airquality)+
  theme_bw()+
  stat_boxplot(aes(log(Ozone+1e-04)),fill="pink")+
  labs(title="Ozone Boxplot after conversion")+
  coord_flip()

skewness(log(Ozone+1e-04))

```

변환 이전에는 stem and leaf display를 활용해서 그래프를 확인할 경우 Skewed to the right되어있는 것을 어느정도 확인할 수 있다. 중간에 blank가 있는 것으로 보아 outlier의 존재 가능성이 존재한다. 또한 stem 1과 2를 기준으로 Cluster가 이루어져 있는데, 높은 수준의 Ozone보다는 낮은 수준의 Ozone양이 많음을 확인할 수 있다. 실제로 Boxplot을 가지고 확인할 경우 결측치가 두개 존재하며, median은 Lower Hinge에 가깝게 설정되어 있다. Skewness는 0.4065394로 계산되어지므로 다시한번 Skewed to the right임을 확인할 수 있다.

변환 이후에 stem and leaf display를 확인할 경우 cluster가 2개에서 stem 3을 중심으로 하는 하나의 cluster로 줄어들었으며, skewed된 정도도 상당히 완화된 것이 확인된다. Boxplot을 통해서 확인할 경우 Outlier가 두개에서 한개로 감소하였으며, whisker의 길이도 위아래 어느정도 비슷해 진 것으로 보인다. skewness 또한 0.1123698로 0.4065394에서 줄어들었으므로 확실히 skewed to the right 되어 있는 성향이 완화된 것으로 보인다. (다만, Ourlier의 발생은 Ozone의 값이 1이라 로그의 성질에 의해서 0으로 계산되어 그러한 것으로 보인다.)

# 4번

지난번 숙제의 도시별 구의 인구 자료를 도시별 퍼짐이 비슷하여지도록 하는 변환을 찾아 전과 후를 비교하여라. (무턱대고 lm 함수를 쓰면 낭패를 볼 수 있으니 조심하여야 한다. '눈대중'이 좋을 때도 많음.)

```{r}
pop2021<-read.csv("https://raw.githubusercontent.com/SangwonJu/data/main/2021.02%20pop.csv",header=T)
pop2021$시=ordered(reorder(pop2021$지역명,pop2021$지역코드))

my_xlab<-paste(levels(pop2021$시),"\n(N=",table(pop2021$시),")",sep="") 
ggplot(data=pop2021,aes(x=시,y=인구,fill=시))+ 
    geom_boxplot(varwidth=T)+ 
    scale_y_continuous(labels = scales::comma)+
    scale_fill_brewer(palette="Pastel1")+ 
    scale_x_discrete(labels=my_xlab)+
    theme_minimal()
```

```{r}
for(i in levels(pop2021$시)){
  assign(paste0("spread",i),fivenum(pop2021$인구[pop2021$시==i])[4] - fivenum(pop2021$인구[pop2021$시==i])[2])
}

pop2021_spread=c(spread서울,spread부산,spread대구,spread인천,spread광주,spread대전,spread울산,spread세종)
pop2021_spread

pop2021_med <- c(median(pop2021$인구[pop2021$시=="서울"]), 
       +      median(pop2021$인구[pop2021$시=="부산"]),
       +      median(pop2021$인구[pop2021$시=="대구"]),
       +      median(pop2021$인구[pop2021$시=="인천"]),
       +      median(pop2021$인구[pop2021$시=="광주"]),
       +      median(pop2021$인구[pop2021$시=="대전"]),
       +      median(pop2021$인구[pop2021$시=="울산"]),
       +      median(pop2021$인구[pop2021$시=="세종"]))
plot(log(pop2021_med), log(pop2021_spread), main="Spread vs. Level plot")

logspread=log(pop2021_spread[1:length(log(pop2021_spread))-1])
logmed=log(pop2021_med[1:length(log(pop2021_med))-1])
(RegrLine <- lm(logspread~logmed))     
abline(coef(RegrLine))
1 - coef(RegrLine)[2] #2.30394



skewness = function(x) {
  hl=fivenum(x)[2]
  median=fivenum(x)[3]
  hu=fivenum(x)[4]
  skew=((hu-median)-(median-hl))/((hu-median)+(median-hl))
  return(skew)
}

x=c()
for(i in levels(pop2021$시)){
  k=skewness(pop2021$인구[pop2021$시==i])
  x=c(x,k)
}
default=data.frame(x)
colnames(default)="skewness_per_city"
rownames(default)=levels(pop2021$시)
mean(default$skewness_per_city,na.rm=T)
```

```{r}
# 순서대로 log, sqrt, negative inverse, negative sqrt inverse

# log
ggplot(data=pop2021,aes(x=시,y=log(인구),fill=시))+ 
  theme_bw()+
  geom_boxplot(varwidth=T)+ 
  scale_y_continuous(labels = scales::comma)+
  scale_fill_brewer(palette="Pastel1")+ 
  scale_x_discrete(labels=my_xlab)

x1=c()
for(i in levels(pop2021$시)){
  k=skewness(log(pop2021$인구[pop2021$시==i]))
  x1=c(x1,k)
}
log=data.frame(x1)
colnames(log)="skewness_per_city"
rownames(log)=levels(pop2021$시)
log
mean(log$skewness_per_city,na.rm=T)

#sqrt
# 가장 대칭성 문제를 잘 해결 한 것으로 보임 (결측치도 적은편)
ggplot(data=pop2021,aes(x=시,y=sqrt(인구),fill=시))+ 
  theme_bw()+
  geom_boxplot(varwidth=T)+ 
  scale_y_continuous(labels = scales::comma)+
  scale_fill_brewer(palette="Pastel1")+ 
  scale_x_discrete(labels=my_xlab) 

x2=c()
for(i in levels(pop2021$시)){
  k=skewness(sqrt(pop2021$인구[pop2021$시==i]))
  x2=c(x2,k)
}
sqrt=data.frame(x2)
colnames(sqrt)="skewness_per_city"
rownames(sqrt)=levels(pop2021$시)
sqrt
mean(sqrt$skewness_per_city,na.rm=T)

#negative inverse

ggplot(data=pop2021,aes(x=시,y=-인구^-(1),fill=시))+ 
  theme_bw()+
  geom_boxplot(varwidth=T)+ 
  scale_y_continuous(labels = scales::comma)+
  scale_fill_brewer(palette="Pastel1")+ 
  scale_x_discrete(labels=my_xlab)

x3=c()
for(i in levels(pop2021$시)){
  k=skewness(-1/(pop2021$인구[pop2021$시==i]))
  x3=c(x3,k)
}
inverse=data.frame(x3)
colnames(inverse)="skewness_per_city"
rownames(inverse)=levels(pop2021$시)
inverse
mean(inverse$skewness_per_city,na.rm=T)

#negative sqrt inverse

ggplot(data=pop2021,aes(x=시,y=-1/sqrt(인구),fill=시))+ 
  theme_bw()+
  geom_boxplot(varwidth=T)+ 
  scale_y_continuous(labels = scales::comma)+
  scale_fill_brewer(palette="Pastel1")+ 
  scale_x_discrete(labels=my_xlab)

x4=c()
for(i in levels(pop2021$시)){
  k=skewness(-1/(sqrt(pop2021$인구[pop2021$시==i])))
  x4=c(x4,k)
}
sqrtinverse=data.frame(x4)
colnames(sqrtinverse)="skewness_per_city"
rownames(sqrtinverse)=levels(pop2021$시)
sqrtinverse
mean(sqrtinverse$skewness_per_city,na.rm=T)

# Spread-versus-level Plot의 기준으로
ggplot(data=pop2021,aes(x=시,y=-인구^-2.30394 ,fill=시))+ 
  theme_bw()+
  geom_boxplot(varwidth=T)+ 
  scale_y_continuous(labels = scales::comma)+
  scale_fill_brewer(palette="Pastel1")+ 
  scale_x_discrete(labels=my_xlab)

x5=c()
for(i in levels(pop2021$시)){
  k=skewness(-1/((pop2021$인구[pop2021$시==i])^-2.30394))
  x5=c(x5,k)
}
lm=data.frame(x5)
colnames(lm)="skewness_per_city"
rownames(lm)=levels(pop2021$시)
lm
mean(lm$skewness_per_city,na.rm=T)

# -2.303에 가까운 정수값 : -2 적용
ggplot(data=pop2021,aes(x=시,y=-인구^-2 ,fill=시))+ 
  theme_bw()+
  geom_boxplot(varwidth=T)+ 
  scale_y_continuous(labels = scales::comma)+
  scale_fill_brewer(palette="Pastel1")+ 
  scale_x_discrete(labels=my_xlab)

x6=c()
for(i in levels(pop2021$시)){
  k=skewness(-1/((pop2021$인구[pop2021$시==i])^-2))
  x6=c(x6,k)
}
lm2=data.frame(x6)
colnames(lm2)="skewness_per_city"
rownames(lm2)=levels(pop2021$시)
lm2
mean(lm2$skewness_per_city,na.rm=T)

combined_skewness=cbind(log,sqrt,inverse,sqrtinverse,lm,lm2)

# Spread-versus-level Plot에 선형회귀분석을 사용하여 얻어진 값을 가지고 Transformation을 진행해 보았으나, 만족할 만한 변환이 이루어지지는 않았다.
# 그 이유로는 데이터의 갯수가 많지 않은 점도 있고, 회귀식 자체가 reliable하지 않은 부분도 있는 것으로 보인다.

library(data.table)
combined_skewness=transpose(combined_skewness)
rownames(combined_skewness)=c("log","sqrt","inverse","sqrtinverse","^-2.30394","^-2")
colnames(combined_skewness)=levels(pop2021$시)
combined_skewness$mean=apply(combined_skewness,1,mean,na.rm=T)
combined_skewness

which.min(abs(combined_skewness$mean))

# 따라서 sqrt일 때가 전체적인 Boxplot의 whisker 비율도 적절하고, H-spread내의 skewness도 작은 편이라고 볼 수 있다.

```
